# 1 查找

## 1.1 查找方式

没有索引的查找

- 在一个页中的查找
  - 索引搜索
    - 在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录，最后需要回表则回表。
  - 非索引搜索
    - 在数据页中没有对非主键列建立页目录，所以无法通过二分法快速定位相应的槽。只能从最小记录依次遍历单链表中的每条记录，然后对比每条记录是否符合搜索条件。

- 在多个页中的查找
  - 索引搜索
    - 1）二分法定位页目录
    - 2）二分法定位页
    - 3）二分法定位数据行（最后需要回表则回表）
  - 非索引搜索
    - 1）遍历所有的列
    - 2）定位到记录所在的页
    - 3）在所在的页中查找相应的记录。



## 1.2 目录项（页目录的目录）

> <font color="blue">**针对页而产生的。**</font>

因为这些16KB的页在物理存储上并不连续，所以如果想从这么多页中根据主键快速定位某些记录所在的页，我们需要给他们做个目录，就像为页中的记录建立一个页目录一样，引擎会为所有的页建立一个目录。每个页对应一个目录项。

### 1.2.1 结构

**这里的结构，只指行的数据（User Record）内容，而非整个结构，整个结构实际就是一个页。**<font color="blue">**也就是说，这里的两个列时主键和页号。**</font>

- 页的用户记录中最小的主键值，用 key 表示。

- 页号，用 page_no 表示。
  ![Snipaste_2020-04-06_21-47-16](..\..\_img\Snipaste_2020-04-06_21-47-16.png)
  ![Snipaste_2020-04-06_23-00-04](..\..\_img\Snipaste_2020-04-06_23-00-04.png)

### 1.2.2 特点

- 结构与页相同，包含页的所有特点；

- 数据列固定，只包含索引列和页号；

- 记录头的信息 **record_type** 属性一定等于**1**；

  （因为所有数据，包括普通数据页中的数据，包括目录项页中的数据，都是连续存放在内存中，因此需要使用 record_type 来进行区分。）
  ![Snipaste_2020-04-06_22-04-20](..\..\_img\Snipaste_2020-04-06_22-04-20.png)

  

### 1.2.3 与普通数据页

- 目录项记录的 record_type = 1，而普通用户记录的 record_type = 0；

- 目录项记录只有主键值和页编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列信息；

- 目录项中的记录最小的数据的行的 min_rec_mask 值为1；

  （record_type 用来筛选目录项，而 min_rec_mask 则可以快速定位目录项的表头位置。）





### 1.2.4 多层级目录项

由于目录项记录的页在存储空间中也是不连续的，因此，为了快速定位目录项记录的页，则需要为目录项记录的页再生成一个跟高级的目录项（层层叠加）。
![Snipaste_2020-04-06_22-06-30](..\..\_img\Snipaste_2020-04-06_22-06-30.png)
![Snipaste_2020-04-06_22-06-57](..\..\_img\Snipaste_2020-04-06_22-06-57.png)



# 2 索引

## 2.1 聚簇索引

> <font color="blue">**聚簇索引的主键值应尽量是连续增长的值，不要随机值或UUID，否则会造成大量的页分裂与页移动。**</font>

- 使用记录主键值大小进行记录和页的排序。
  - 页内的记录是按照主键的大小顺序排成一个单向链表。
  - 各个存放用户记录的页是根据页中记录的主键大小顺序排成一个双向链表。
  - 各个存放目录项的页是根据页中记录的主键大小顺序排成一个双向链表。
- B+树的叶子节点存储的是完整的用户记录。

- 不需要显示创建，引擎自动创建。
- 聚簇索引就是数据的存储方式（所有的用户记录都存在叶子节点，<font color="blue">**索引即数据**</font>）。



## 2.2 二级索引

聚簇索引的B+树使用主键进行排序，而自定义的B+树可以采用其他的排序规则。

### 2.2.1 特性

- 使用记录 c 列的大小进行记录和页的排序
  - 1）页内的记录是按照 c 列值的大小顺序排成一个单向链表。
  - 2）各个存放用户记录的页是根据页中的记录的 c 列大小顺序排成一个双向链表。
  - 3）各个存放目录项的页也是根据页中的记录的 c 列大小顺序排成一个双向链表。
- B+树的叶子节点存储的并不是完整的用户记录，而是 <font color="blue">**c 列 + 主键**</font>。
- 目录项记录中不再是 <font color="blue">**主键 + 页号**</font>，而是 <font color="blue">**c 列 + 页号**</font>。

### 2.2.2 重点

#### 不需要回表（<font color="red">索引覆盖</font>）

如果一个索引包含（或覆盖）所有需要查询的字段值，则成为 『**覆盖索引**』，无需回表。

- 不用回表，减少二次查询，减少随机IO；
- 减少遍历数据页的数量。

如：直接通过 c 列的值查到某些记录的话，则使用二级索引的B+树即可：

```sql
select name from user where name = 1;
```

#### 需要回表

当二级索引的B+树不包含需要的数据时，需要根据查到的主键值，再去聚簇索引中查找完整的用户记录：

```sql
select name, age from user where c = 1;
```



## 2.3 组合索引

### 2.3.1 特性

只生成1颗B+树，却同时以多个列的大小作为排序规则，即让B+树按照 name 和 age 的大小进行排序：

- 先把各个记录和页按照 name 进行排序（<font color="blue">**最左优先**</font>）。
- 在记录的 name 列相同的情况下，采用 age 进行排序。
  ![Snipaste_2020-04-06_22-43-55](..\..\_img\Snipaste_2020-04-06_22-43-55.png)

### 2.3.2 推荐原则

- 联合索引总体选择性越高越好。
- 分组及排序时，让排序沿着某个索引顺序，防止二次排序。
- 在不考虑分组及排序时，尽量选择区分度高的列作为联合索引的前导列。B+树是按照前导列进行排序的，将选择性高的列放到前面能够最快地过滤出需要的记录。
- 联合索引长度不宜过长，可利用前缀索引降低索引条目长度。



## 2.4 前缀索引

### 2.4.1 示例

假设当前索引结构为联合索引：(c2, c3, c4)

- 对于 (c2, c3, c4) 这样的数据检索时，B+树按照从左到右的顺序来搜索。

- 如果没有 c2，按照 (c3, c4) 这样检索时，B+树会因为找不到 c2，而无法使用索引。

- 如果没有 c3，按照 (c2, c4) 这样检索时，B+树会先使用 c2 来指定搜索方向，但由于 c3 的缺失，所以只能等 c2 都找到，最后遍历匹配 c4。

### 2.4.2 重点特例

- 从左向右匹配，直到遇到范围查询（>、<、between、like）就停止匹配。

  ```sql
  where a = 1 and b = 2 and c > 3 and d = 4
  ```

  - 如果建立 (a, b, c, d) 顺序的索引，d 是用不到索引。
  - 如果建立 (a, b, d, c) 顺序的索引，则都可以用到。

- = 和 in 是可以乱序的，优化器会自动识别优化。

  ```sql
  where a = 1 and b = 2 and c = 3;
  where b = 2 and a = 1 and c = 3;
  ```

  - 以上两者都是可以使用 (a, b, c) 组合索引。









using index condition;

说明过滤了索引，ICP，索引下放特性；



# 3 索引排序

## 3.1 特点

> 由于检索使用到联合索引的数据，必定是有序的，则如果 order by 后面的条件，如果是按照联合索引的顺序，则不需要再次进行排序，否则还需要再次排序。

- order by 沿着某个索引的顺序，查询的结果本身就是有序的。

- 先取出数据，形成临时表做 filesort（文件可能在磁盘上，也可能在内存中）。



## 3.2 原则

- order by 语句使用了索引最左前缀。

- where 条件与 order by 条件的组合满足索引最左前缀。



## 3.3 示例

> 示例1

索引：(a, b, c)

- 使用索引

  ```sql
  select * from user order by a, b;
  select * from user where a = 1 order by b;
  ```

- 不使用索引

  ```sql
  # 无(c, b)索引
  select * from user where a = 1 order by c, b;
  # 因为最左前缀遇到非等号会重新计算
  select * from user where a > 1 order by b;
  ```

> 示例2

索引：(c1, c2, c3, c4)

- 正常使用c1索引和c4索引，不需要排序；

  ```sql
  # Using index condition; Using where
  select * from user where c1 = 1, c4 = 2 order by c2, c3;
  ```

- 虽然也会使用索引，但是最后会多出一步二次排序；

  ```sql
  # Using index condition; Using where; Using filesort
  select * from user where c1 = 1, c4 = 2 order by c3, c2;
  ```



# 4 索引分组

> MySQL 8.0 取消了对 GROUP BY 的默认排序！

由于 group by 会默认进行 order by，因此效果也是一样的，如果不需要 order by，则需要取消排序。



# 1 InnoDB 页结构

## 1.1 简介

数据被划分为若干个页，以页作为磁盘和内存之间交互的基本单位，一般为16KB，且<font color="blue">**页内的物理地址是连续的**</font>。最小记录、最大记录和用户记录，三者为主要数据，其中理论上存储了各个行信息，但实际上是**多个行信息**组合成的一条连续的数据。

MySQL走索引怎么查到数据（innodb引擎以页的形式将数据储存到磁盘，查询时将页读入内存，在叶子节点中查取数据，叶节点内部通过二分法查找，找不到转到该页指向的下一个页继续查询）





- **页结构示意**
  <img src="..\..\_img\Snipaste_2020-04-05_13-53-59.png" alt="MySQL页结构" style="zoom: 80%;" />
- **数据存储过程**
  ![Snipaste_2020-04-05_21-59-26](..\..\_img\Snipaste_2020-04-05_21-59-26.png)



## 1.2 行

> <font size="5">**infimum，supremum，User Records**</font>

### 1.2.1 Compact（重要）

#### 1.2.1.1 使用语法

```sql
# 创建语法
CREATE TABLE 表名(
    列的信息
) ROW_FORMAT = 行格式名称
# 修改语法
ALTER TABLE 表名 ROW_FORMAT = 行格式名称
```

#### 1.2.1.2 格式

##### 1.2.1.2.1 简介

- a）结构图：
  ![行格式信息](..\..\_img\行格式信息.png)
- b）示例图：
  ![Snipaste_2020-04-05_20-12-30](..\..\_img\Snipaste_2020-04-05_20-12-30.png)
- c）剖析图：
  ![详解01](..\..\_img\Snipaste_2020-04-05_14-41-03.png)
- 1）**变长字段长度列表**，根据列表长度决定占用字节，如：01 03 04；
  - 2）**NULL 标志位**，如：00；
  - 3）**记录头信息**，固定5个字节，如：00 00 00 10 00；
  - 4）**行ID**，固定6个字节，如：00 00 00 00 05 00；
  - 5）**事务ID**，固定6个字节，如：00 00 00 01 43 11；
  - 6）**回滚指针**，固定7个字节，如：8e 00 00 01 a3 01 10；
  - 7）**列的数据**，根据列数据长度决定占用字节。如：61 61 61 61 62 62 62 63 63 20 20 20 20 20 20 20 20 64；

##### 1.2.1.2.2 结构详解

###### 行的额外信息

- 变长列长度列表

  （把所有变长类型列的长度存放在行记录的开头部位形成一个列表，按照列的顺序<font color="blue">逆序存放</font>。）

  - 真正的数据内容
  - 占用的字节数

- NULL 值列表

  （如果把NULL值都放到记录的真实数据中存储，会很占空间，所以把这些值为NULL的列同一管理，存储到NULL值列表中，可以理解为标记列表。）

- 行头信息（记录头信息）

  **a 结构图：**
  ![记录头信息](..\..\_img\记录头信息.png)

  **b 示例图：**
  ![2020-04-06_113953](..\..\_img\2020-04-06_113953.png)

  - **delete_mask**

    标记当前记录是否被删除，占用1个二进制位，0=存在，1=删除；

  - **min_rec_mask**

    标记该记录是否为B+树的非叶子节点中的最小记录。

  - **heap_no（物理页顺序）**

    当前记录在本页中的位置，是物理页的编号，InnoDB会自动在每个页里加两条记录，这两条记录也成为伪记录或虚拟记录。一个代表最小记录（infimum），一个代表最大记录（supremum）。由于 infimum 和 supremum 各占用1个“位置”，序号为0和1，导致实际插入数据后，从2开始计数。

  - **record_type**

    记录类型，0=普通记录，1=B+树非叶节点记录，2=最小记录，3=最大记录；

  - **next_record（逻辑顺序，<font color="red">主键地址链表</font>）**

    1. 表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量；
    2. 下一条记录指的并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。
    3. 规定『最小记录』 的下一条记录是本页中主键值最小的记录，而本页中主键值最大的记录的下一条记录就是『最大记录』；

###### 真实数据

> 每条记录都会添加 transaction_id 和 roll_pointer，但 row_id 只有在表没有定义主键的时候才会为记录添加，相当于默认主键。

- **row_id**（非必须）：6 字节，表示行ID，唯一标识一条记录。
- **transaction_id**（必须）：6 字节，表示事务ID。
- **roll_pointer**（必须）：7 字节，回滚指针。

#### 1.2.1.3 Tips

- 如果 VARCHAR 类型的列没有 NOT NULL 属性，那最多只能存储 65532 个字节的数据，因为真实数据的长度需要占用2个字节，NULL 值标识需要占用1个字节；如果有 NOT NULL 属性，那最多只能存储 65533 个字节的数据。
- 一个页的大小一般是16KB，也就是16384字节，因此，可能造成1个页存放不下一条记录，则需要多页存储1条记录（会存储一个指向其他页的地址）。

### 1.2.2 Redundant，Dynamic，Compressed

略





## 1.3 页目录

> - <font color="blue">**页目录里存放的单位是槽**</font>
> - <font color="blue">**每个槽代表1组记录**</font>
> - <font color="blue">**定位到某个页后，需要二分查找其中的行时，就需要用到目录。**</font>
> - <font color="blue">**针对数据行而产生的的。**</font>

将所有正常的记录（包括最大最小记录，不包括标记为删除的记录）划分为几个组。

每个组的最后一条记录的头信息中的 n_owned 属性表示该组内公有几条记录。

将每个组的最后一条记录的地址偏移量按顺序存储起来，每个地址偏移量也被称为一个槽（每个槽会保存到页目录中）。这些地址偏移量都会被存储到靠近页的尾部的地方，页中存储地址偏移量的部分也被称为 Page Directory。

![Snipaste_2020-04-06_14-19-54](..\..\_img\Snipaste_2020-04-06_14-19-54.png)

- 1）初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。
- 2）之后每插入一条记录都把这条记录放到最大记录所在的组，直到最大记录所在的组中的记录数等于8个。
- 3）在最大记录所在组中的记录数等于8个（为什么是8个？）的时候再插入一条记录时，将最大记录锁在组平均分裂成2个组，然后最大记录所在的组就剩下4条记录了，然后就可以把即将插入的那条记录放到相应的组中了。
- 4）页目录中的各个槽代表的记录的主键值都是从小到大排序的，所以可以使用二分法来进行快速查找。
- 5）通过记录的 next_record 属性组成的链表遍历查找该槽中的各个记录。

## 1.4 File Header

> 也是描述页的信息，主要作用记录以下数据

- FIL_PAGE_OFFSET：页号
- FIL_PAGE_PREV：上一个页的页号
- FIL_PAGE_NEXT：下一个页的页号（形成双链表结构）
- FIL_PAGE_TYPE：该页的类型
  - FIL_PAGE_TYPE_BLOB：BLOB页
  - FIL_PAGE_INDEX：B+树的子节点



## 1.5 Page Header

- PAGE_N_DIR_SLOTS：在页目录中的槽的数量；
- PAGE_HEAP_TOP：第一个记录的地址；
- PAGE_N_HEAP：本业中的记录的数量（包括最大最小，以及删除的）；
- PAGE_FREE：标记为删除的记录地址；
- PAGE_GARBAGE：已删除的字节数；
- PAGE_LAST_INSERT：最后插入记录的位置；
- PAGE_N_RECS：该页中的记录数量（不包括最大最小，删除记录）；
- PAGE_MAX_TRX_ID：修改当前页的最大事务ID，该值仅在二级索引中定义；
- PAGE_LEVEL：当前页在索引树中的位置，高度；



## 1.6 File Trailer

用于检测一个页是否完整，每个页尾部由8个字节组成一个Trailer。

- 前4个字节代表页的校验和。
- 后4个字节代表日志序列位置（LSN）。



# 2 行迁移

由于页与页之间是递增主键值，则当插入的主键值小于当前记录的最大值，则会伴随一次记录的移动，保证整个链表关系是有小到大的。

- 耗资源，因此推荐使用自增列来控制。



# 3 总结

- InnoDB 数据页由7个部分组成，各个数据页可以组成一个<font color="red">**双向链表**</font>，而每个数据页中的记录又可以组成一个<font color="red">**单向链表**</font>，每个数据页都会为存储在它里面的记录生成一个<font color="red">**页目录**</font>。在通过主键查找某条记录时，可以在页目录中使用二分法快速定位到相应的<font color="red">**槽**</font>，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。
- 下一个数据页中的主键值必须大于上一个页中的主键值。